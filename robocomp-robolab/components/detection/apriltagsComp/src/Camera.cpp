//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.2
//
// <auto-generated>
//
// Generated from file `Camera.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Camera.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit<::RoboCompCamera::HardwareFailedException> iceC_RoboCompCamera_HardwareFailedException_init("::RoboCompCamera::HardwareFailedException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::RoboCompCamera::MovingImageException> iceC_RoboCompCamera_MovingImageException_init("::RoboCompCamera::MovingImageException");

const ::std::string iceC_RoboCompCamera_Camera_ids[2] =
{
    "::Ice::Object",
    "::RoboCompCamera::Camera"
};
const ::std::string iceC_RoboCompCamera_Camera_ops[] =
{
    "getCamParams",
    "getRGBPackedImage",
    "getYImage",
    "getYImageCR",
    "getYLogPolarImage",
    "getYRGBImage",
    "getYUVImage",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInnerImage"
};
const ::std::string iceC_RoboCompCamera_Camera_getYUVImage_name = "getYUVImage";
const ::std::string iceC_RoboCompCamera_Camera_getYImage_name = "getYImage";
const ::std::string iceC_RoboCompCamera_Camera_getYLogPolarImage_name = "getYLogPolarImage";
const ::std::string iceC_RoboCompCamera_Camera_getYImageCR_name = "getYImageCR";
const ::std::string iceC_RoboCompCamera_Camera_getRGBPackedImage_name = "getRGBPackedImage";
const ::std::string iceC_RoboCompCamera_Camera_getYRGBImage_name = "getYRGBImage";
const ::std::string iceC_RoboCompCamera_Camera_getCamParams_name = "getCamParams";
const ::std::string iceC_RoboCompCamera_Camera_setInnerImage_name = "setInnerImage";

}

RoboCompCamera::HardwareFailedException::~HardwareFailedException()
{
}

const ::std::string&
RoboCompCamera::HardwareFailedException::ice_staticId()
{
    static const ::std::string typeId = "::RoboCompCamera::HardwareFailedException";
    return typeId;
}

RoboCompCamera::MovingImageException::~MovingImageException()
{
}

const ::std::string&
RoboCompCamera::MovingImageException::ice_staticId()
{
    static const ::std::string typeId = "::RoboCompCamera::MovingImageException";
    return typeId;
}

bool
RoboCompCamera::Camera::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_RoboCompCamera_Camera_ids, iceC_RoboCompCamera_Camera_ids + 2, s);
}

::std::vector<::std::string>
RoboCompCamera::Camera::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_RoboCompCamera_Camera_ids[0], &iceC_RoboCompCamera_Camera_ids[2]);
}

::std::string
RoboCompCamera::Camera::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
RoboCompCamera::Camera::ice_staticId()
{
    static const ::std::string typeId = "::RoboCompCamera::Camera";
    return typeId;
}

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYUVImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    istr->readAll(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYUVImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    istr->readAll(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYLogPolarImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    istr->readAll(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYLogPolarImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYImageCR(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    int iceP_div;
    istr->readAll(iceP_cam, iceP_div);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYImageCR(iceP_cam, iceP_div, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getRGBPackedImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    istr->readAll(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getRGBPackedImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYRGBImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    int iceP_cam;
    istr->readAll(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYRGBImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_roi, iceP_hState, iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getCamParams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    TCamParams ret = this->getCamParams(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_setInnerImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    imgType iceP_roi;
    istr->readAll(iceP_roi);
    inS.endReadParams();
    this->setInnerImage(::std::move(iceP_roi), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_RoboCompCamera_Camera_ops, iceC_RoboCompCamera_Camera_ops + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_RoboCompCamera_Camera_ops)
    {
        case 0:
        {
            return _iceD_getCamParams(in, current);
        }
        case 1:
        {
            return _iceD_getRGBPackedImage(in, current);
        }
        case 2:
        {
            return _iceD_getYImage(in, current);
        }
        case 3:
        {
            return _iceD_getYImageCR(in, current);
        }
        case 4:
        {
            return _iceD_getYLogPolarImage(in, current);
        }
        case 5:
        {
            return _iceD_getYRGBImage(in, current);
        }
        case 6:
        {
            return _iceD_getYUVImage(in, current);
        }
        case 7:
        {
            return _iceD_ice_id(in, current);
        }
        case 8:
        {
            return _iceD_ice_ids(in, current);
        }
        case 9:
        {
            return _iceD_ice_isA(in, current);
        }
        case 10:
        {
            return _iceD_ice_ping(in, current);
        }
        case 11:
        {
            return _iceD_setInnerImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getYUVImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetYUVImageResult>>& outAsync, int iceP_cam, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYUVImage_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getYUVImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const HardwareFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetYUVImageResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getYImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetYImageResult>>& outAsync, int iceP_cam, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYImage_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getYImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const MovingImageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetYImageResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getYLogPolarImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetYLogPolarImageResult>>& outAsync, int iceP_cam, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYLogPolarImage_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getYLogPolarImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const MovingImageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetYLogPolarImageResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getYImageCR(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetYImageCRResult>>& outAsync, int iceP_cam, int iceP_div, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYImageCR_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getYImageCR_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam, iceP_div);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const MovingImageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetYImageCRResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getRGBPackedImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetRGBPackedImageResult>>& outAsync, int iceP_cam, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getRGBPackedImage_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getRGBPackedImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const MovingImageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetRGBPackedImageResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getYRGBImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Camera::GetYRGBImageResult>>& outAsync, int iceP_cam, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYRGBImage_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getYRGBImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_cam);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const MovingImageException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            Camera::GetYRGBImageResult v;
            istr->readAll(v.roi, v.hState, v.bState);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_getCamParams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TCamParams>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getCamParams_name);
    outAsync->invoke(iceC_RoboCompCamera_Camera_getCamParams_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::CameraPrx::_iceI_setInnerImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const imgType& iceP_roi, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_RoboCompCamera_Camera_setInnerImage_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_roi);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
RoboCompCamera::CameraPrx::_newInstance() const
{
    return ::IceInternal::createProxy<CameraPrx>();
}
/// \endcond

const ::std::string&
RoboCompCamera::CameraPrx::ice_staticId()
{
    return Camera::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_RoboCompCamera_Camera_getYUVImage_name = "getYUVImage";

const ::std::string iceC_RoboCompCamera_Camera_getYImage_name = "getYImage";

const ::std::string iceC_RoboCompCamera_Camera_getYLogPolarImage_name = "getYLogPolarImage";

const ::std::string iceC_RoboCompCamera_Camera_getYImageCR_name = "getYImageCR";

const ::std::string iceC_RoboCompCamera_Camera_getRGBPackedImage_name = "getRGBPackedImage";

const ::std::string iceC_RoboCompCamera_Camera_getYRGBImage_name = "getYRGBImage";

const ::std::string iceC_RoboCompCamera_Camera_getCamParams_name = "getCamParams";

const ::std::string iceC_RoboCompCamera_Camera_setInnerImage_name = "setInnerImage";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::RoboCompCamera::HardwareFailedException> iceC_RoboCompCamera_HardwareFailedException_init("::RoboCompCamera::HardwareFailedException");

}

RoboCompCamera::HardwareFailedException::HardwareFailedException(const ::std::string& what) :
    ::Ice::UserException(),
    what(what)
{
}

RoboCompCamera::HardwareFailedException::~HardwareFailedException() throw()
{
}

::std::string
RoboCompCamera::HardwareFailedException::ice_id() const
{
    return "::RoboCompCamera::HardwareFailedException";
}

RoboCompCamera::HardwareFailedException*
RoboCompCamera::HardwareFailedException::ice_clone() const
{
    return new HardwareFailedException(*this);
}

void
RoboCompCamera::HardwareFailedException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
RoboCompCamera::HardwareFailedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::RoboCompCamera::HardwareFailedException", -1, true);
    ::Ice::StreamWriter< HardwareFailedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
RoboCompCamera::HardwareFailedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< HardwareFailedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::RoboCompCamera::MovingImageException> iceC_RoboCompCamera_MovingImageException_init("::RoboCompCamera::MovingImageException");

}

RoboCompCamera::MovingImageException::MovingImageException(const ::std::string& what) :
    ::Ice::UserException(),
    what(what)
{
}

RoboCompCamera::MovingImageException::~MovingImageException() throw()
{
}

::std::string
RoboCompCamera::MovingImageException::ice_id() const
{
    return "::RoboCompCamera::MovingImageException";
}

RoboCompCamera::MovingImageException*
RoboCompCamera::MovingImageException::ice_clone() const
{
    return new MovingImageException(*this);
}

void
RoboCompCamera::MovingImageException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
RoboCompCamera::MovingImageException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::RoboCompCamera::MovingImageException", -1, true);
    ::Ice::StreamWriter< MovingImageException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
RoboCompCamera::MovingImageException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MovingImageException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::RoboCompCamera::upCast(Camera* p) { return p; }

void
::IceProxy::RoboCompCamera::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Camera>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Camera;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getYUVImage(::Ice::Int iceP_cam, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYUVImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getYUVImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getYUVImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getYUVImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getYUVImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYUVImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::HardwareFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getYUVImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYUVImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::HardwareFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getYImage(::Ice::Int iceP_cam, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getYImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getYImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getYImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getYImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getYImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getYLogPolarImage(::Ice::Int iceP_cam, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYLogPolarImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getYLogPolarImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getYLogPolarImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getYLogPolarImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getYLogPolarImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYLogPolarImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getYLogPolarImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYLogPolarImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getYImageCR(::Ice::Int iceP_cam, ::Ice::Int iceP_div, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYImageCR_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getYImageCR_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getYImageCR_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        ostr->write(iceP_div);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getYImageCR_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getYImageCR(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYImageCR_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getYImageCR(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYImageCR_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getRGBPackedImage(::Ice::Int iceP_cam, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getRGBPackedImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getRGBPackedImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getRGBPackedImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getRGBPackedImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getRGBPackedImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getRGBPackedImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getRGBPackedImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getRGBPackedImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getYRGBImage(::Ice::Int iceP_cam, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getYRGBImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getYRGBImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getYRGBImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_cam);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_getYRGBImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_getYRGBImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYRGBImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

void IceProxy::RoboCompCamera::Camera::_iceI_end_getYRGBImage(::RoboCompCamera::imgType& iceP_roi, ::RoboCompCommonHead::THeadState& iceP_hState, ::RoboCompGenericBase::TBaseState& iceP_bState, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getYRGBImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::RoboCompCamera::MovingImageException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_roi);
    istr->read(iceP_hState);
    istr->read(iceP_bState);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_getCamParams(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_RoboCompCamera_Camera_getCamParams_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_getCamParams_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_getCamParams_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_RoboCompCamera_Camera_getCamParams_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::RoboCompCamera::TCamParams
IceProxy::RoboCompCamera::Camera::end_getCamParams(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_RoboCompCamera_Camera_getCamParams_name);
    ::RoboCompCamera::TCamParams ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::RoboCompCamera::Camera::_iceI_begin_setInnerImage(const ::RoboCompCamera::imgType& iceP_roi, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_RoboCompCamera_Camera_setInnerImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_RoboCompCamera_Camera_setInnerImage_name, ::Ice::Idempotent, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_roi);
        result->endWriteParams();
        result->invoke(iceC_RoboCompCamera_Camera_setInnerImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::RoboCompCamera::Camera::end_setInnerImage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_RoboCompCamera_Camera_setInnerImage_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::RoboCompCamera::Camera::_newInstance() const
{
    return new Camera;
}
/// \endcond

const ::std::string&
IceProxy::RoboCompCamera::Camera::ice_staticId()
{
    return ::RoboCompCamera::Camera::ice_staticId();
}

RoboCompCamera::Camera::~Camera()
{
}

/// \cond INTERNAL
::Ice::Object* RoboCompCamera::upCast(Camera* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_RoboCompCamera_Camera_ids[2] =
{
    "::Ice::Object",
    "::RoboCompCamera::Camera"
};

}

bool
RoboCompCamera::Camera::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_RoboCompCamera_Camera_ids, iceC_RoboCompCamera_Camera_ids + 2, s);
}

::std::vector< ::std::string>
RoboCompCamera::Camera::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_RoboCompCamera_Camera_ids[0], &iceC_RoboCompCamera_Camera_ids[2]);
}

const ::std::string&
RoboCompCamera::Camera::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
RoboCompCamera::Camera::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::RoboCompCamera::Camera";
    return typeId;
#else
    return iceC_RoboCompCamera_Camera_ids[1];
#endif
}

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYUVImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    istr->read(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYUVImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    istr->read(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYLogPolarImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    istr->read(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYLogPolarImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYImageCR(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    ::Ice::Int iceP_div;
    istr->read(iceP_cam);
    istr->read(iceP_div);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYImageCR(iceP_cam, iceP_div, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getRGBPackedImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    istr->read(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getRGBPackedImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getYRGBImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_cam;
    istr->read(iceP_cam);
    inS.endReadParams();
    imgType iceP_roi;
    ::RoboCompCommonHead::THeadState iceP_hState;
    ::RoboCompGenericBase::TBaseState iceP_bState;
    this->getYRGBImage(iceP_cam, iceP_roi, iceP_hState, iceP_bState, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_roi);
    ostr->write(iceP_hState);
    ostr->write(iceP_bState);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_getCamParams(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    TCamParams ret = this->getCamParams(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceD_setInnerImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    imgType iceP_roi;
    istr->read(iceP_roi);
    inS.endReadParams();
    this->setInnerImage(iceP_roi, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_RoboCompCamera_Camera_all[] =
{
    "getCamParams",
    "getRGBPackedImage",
    "getYImage",
    "getYImageCR",
    "getYLogPolarImage",
    "getYRGBImage",
    "getYUVImage",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInnerImage"
};

}

/// \cond INTERNAL
bool
RoboCompCamera::Camera::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_RoboCompCamera_Camera_all, iceC_RoboCompCamera_Camera_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_RoboCompCamera_Camera_all)
    {
        case 0:
        {
            return _iceD_getCamParams(in, current);
        }
        case 1:
        {
            return _iceD_getRGBPackedImage(in, current);
        }
        case 2:
        {
            return _iceD_getYImage(in, current);
        }
        case 3:
        {
            return _iceD_getYImageCR(in, current);
        }
        case 4:
        {
            return _iceD_getYLogPolarImage(in, current);
        }
        case 5:
        {
            return _iceD_getYRGBImage(in, current);
        }
        case 6:
        {
            return _iceD_getYUVImage(in, current);
        }
        case 7:
        {
            return _iceD_ice_id(in, current);
        }
        case 8:
        {
            return _iceD_ice_ids(in, current);
        }
        case 9:
        {
            return _iceD_ice_isA(in, current);
        }
        case 10:
        {
            return _iceD_ice_ping(in, current);
        }
        case 11:
        {
            return _iceD_setInnerImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
RoboCompCamera::Camera::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Camera, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
RoboCompCamera::Camera::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Camera, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
RoboCompCamera::_icePatchObjectPtr(CameraPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CameraPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Camera::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
